#
# Executes commands at the start of an interactive session.
#
# Authors:
#   Sorin Ionescu <sorin.ionescu@gmail.com>
#
#

fpath=(/usr/local/share/zsh-completions $fpath)

# Source Prezto.
if [[ -s "${ZDOTDIR:-$HOME}/.zprezto/init.zsh" ]]; then
  source "${ZDOTDIR:-$HOME}/.zprezto/init.zsh"
fi

setopt interactivecomments

[ -f ~/.fzf.zsh ] && source ~/.fzf.zsh
[ -f ~/projects/z/z.sh ] && source ~/projects/z/z.sh

eval "$(hub alias -s)"
[[ -s "$(brew --prefix dvm)/dvm.sh" ]] && source "$(brew --prefix dvm)/dvm.sh"
source <(kubectl completion zsh)
# Openshift completion for `oc`
source <(oc completion zsh)
source $(which assume-role)

# List folders, and sizes
alias ducks='du -cksh * | sort -rn|head -11'

# ssh aliases
alias chat="ssh cloud -t 'tmux attach -d -t chat'"
alias chatm="mosh cloud -- tmux attach -d -t chat"
alias opsignin='eval $(op signin chancez.1password.com chance.zibolski@gmail.com A3-GERNM3-T7F7QX-WEQCD-5PARX-F59D6-AMGG7)'

# Find python file
alias pyfind='find . -name "*.py"'
# Remove python compiled byte-code
alias pyclean='find . -type f -name "*.py[co]" -exec rm -f \{\} \;'

alias gst='git status'
alias gi='git'
alias vim='nvim'

function minikube() {
    (export KUBECONFIG=$HOME/.kube/configs/minikube.yaml && command minikube "$@")
}

alias glgs="git log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr)%Creset' --abbrev-commit --date=relative"

eval "$(direnv hook zsh)"
eval "$(fasd --init auto)"
#eval "$(tmuxifier init -)"
#alias v='f -t -e vim -b viminfo'
#alias sb='f -t -e subl'


# opens files in ~/.viminfo
v() {
  local files
  files=$(f -t -l -b viminfo |
          while read line; do
            [ -f "${line/\~/$HOME}" ] && echo "$line"
          done | fzf -d -m -q "$*" -1) && vim ${files//\~/$HOME}
}

# Here is another version that also supports relaunching z with the arguments for the previous command as the default input by using zz
unalias z 2> /dev/null
z() {
  if [[ -z "$*" ]]; then
    cd "$(_z -l 2>&1 | fzf +s --tac | sed 's/^[0-9,.]* *//')"
  else
    _last_z_args="$@"
    _z "$@"
  fi
}

zz() {
  cd "$(_z -l 2>&1 | sed 's/^[0-9,.]* *//' | fzf -q "$_last_z_args")"
}

alias j=z
alias jj=zz

# fe [FUZZY PATTERN] - Open the selected file with the default editor
#   - Bypass fuzzy finder if there's only one match (--select-1)
#   - Exit if there's no match (--exit-0)
fe() {
  local files
  IFS=$'\n' files=($(fzf-tmux --query="$1" --multi --select-1 --exit-0))
  [[ -n "$files" ]] && ${EDITOR:-vim} "${files[@]}"
}

# Modified version where you can press
#   - CTRL-O to open with `open` command,
#   - CTRL-E or Enter key to open with the $EDITOR
fo() {
  local out file key
  out=$(fzf --query="$1" --exit-0 --expect=ctrl-o,ctrl-e)
  key=$(head -1 <<< "$out")
  file=$(head -2 <<< "$out" | tail -1)
  if [ -n "$file" ]; then
    [ "$key" = ctrl-o ] && open "$file" || ${EDITOR:-vim} "$file"
  fi
}


find_nohidden() {
  find ${1:-*} -path '*/\.*' -prune -o -type d -print 2> /dev/null
}

find_hidden() {
  find ${1:-.} -type d 2> /dev/null
}

# fj - changing directory with fasd
fj() {
  local dir
  dir=$(fasd -Rdl | fzf --no-sort +m) && cd "$dir"
}

# fd - cd to selected directory passed as argument
fd() {
  local dir
  dir=$(find_nohidden ${1:-*} | fzf +m) && cd "$dir"
}

# fda - including hidden directories
fda() {
  local dir
  dir=$(find_hidden ${1:-.}| fzf +m) && cd "$dir"
}

# fkill - kill process
fkill() {
  pid=$(ps -ef | sed 1d | fzf -m | awk '{print $2}')

  if [ "x$pid" != "x" ]
  then
    kill -${1:-9} $pid
  fi
}

fbr() {
  local branches branch
  branches=$(git branch) &&
  branch=$(echo "$branches" | fzf +m) &&
  git checkout $(echo "$branch" | sed "s/.* //")
}

# fco - checkout git branch/tag
fco() {
  local tags branches target
  tags=$(
    git tag | awk '{print "\x1b[31;1mtag\x1b[m\t" $1}') || return
  branches=$(
    git branch --all | grep -v HEAD             |
    sed "s/.* //"    | sed "s#remotes/[^/]*/##" |
    sort -u          | awk '{print "\x1b[34;1mbranch\x1b[m\t" $1}') || return
  target=$(
    (echo "$tags"; echo "$branches") |
    fzf-tmux -l30 -- --no-hscroll --ansi +m -d "\t" -n 2) || return
  git checkout $(echo "$target" | awk '{print $2}')
}

# fshow - git commit browser
fshow() {
  local out sha q
  while out=$(
      git log --decorate=short --graph --oneline --color=always |
      fzf --ansi --multi --no-sort --reverse --query="$q" --print-query); do
    q=$(head -1 <<< "$out")
    while read sha; do
      [ -n "$sha" ] && git show --color=always $sha | less -R
    done < <(sed '1d;s/^[^a-z0-9]*//;/^$/d' <<< "$out" | awk '{print $1}')
  done
}

# fh - repeat history
fh() {
  print -z $( ([ -n "$ZSH_NAME" ] && fc -l 1 || history) | fzf +s --tac | sed 's/ *[0-9]* *//')
}

k() {
    command kubectl --namespace="${KUBE_NAMESPACE:-default}" $@
}

alias kgp='k get pods'
alias kgs='k get svc'
alias kgn='k get ns'

kubectl() {
    k "$@"
}

kn() {
    kns "$@"
}

kc() {
    local config_dir="$HOME/.kube/configs"
    if [ -n "$1" ]; then
        export KUBECONFIG="${config_dir}/${1}.yaml"
        return
    fi

    local config_dir="$HOME/.kube/configs"
    local configs="$(find $config_dir -name '*.yaml')"
    # get just the name of the file without the base path or the yaml extension
    local clean_configs=$(echo "$configs" | xargs basename | sed 's/\.yaml//')
    # if our KUBECONFIG is already set, then check if it's set to a kubeconfig
    # in our kubeconfig dir
    if [ -n "$KUBECONFIG" ]; then
        local current="$KUBECONFIG"
        local current_clean="$(basename $current | sed 's/\.yaml//')"
        # if the current kubeconfig is one of the available options, bolden it
        # for selection
        if echo $configs | grep -q "$current"; then
            clean_configs=$(echo "$clean_configs" | sed "s/$current_clean/$(tput bold)$current_clean$(tput sgr0)/")
        fi
    fi
    local fzf_cmd=(fzf --select-1 --ansi)
    if [ -z "$DISABLE_KC_PREVIEW" ]; then
        local jq_expr='del(.users,.clusters[].cluster["certificate-authority-data"])'
        fzf_cmd+=(--preview 'faq -f yaml '"'$jq_expr'"' '"$config_dir"'/{}.yaml | head -$LINES')
    fi
    export KUBECONFIG="$(echo "$clean_configs" | "${fzf_cmd[@]}" | xargs printf "$config_dir/%s.yaml")"
}

kns() {
    if [ -n "$1" ]; then
        export KUBE_NAMESPACE="$1"
        return
    fi
    local ns="${KUBE_NAMESPACE:-default}"
    local namespaces="$(command kubectl get ns -o=custom-columns=:.metadata.name --no-headers)"
    local fzf_cmd=(fzf --select-1 --ansi)
    if [ -z "$DISABLE_KNS_PREVIEW" ]; then
        fzf_cmd+=(--preview 'command kubectl get pods --namespace {} | head -$LINES')
    fi
    export KUBE_NAMESPACE="$(echo "$namespaces" | sed "s/$ns/$(tput bold)$ns$(tput sgr0)/" | "${fzf_cmd[@]}" )"
}

kcns() {
    if [ -n "$1" ]; then
        kc "$1"
    else
        kc
    fi
    if [ -n "$2" ]; then
        kns "$2"
    else
        kns
    fi
}

function kpod() {
    local CMD=(kubectl get pods --no-headers)
    local NAMESPACE="$1"
    if [ -n "$NAMESPACE" ]; then
        CMD+=(--namespace "$NAMESPACE")
    fi
    "${CMD[@]}" | fzf --select-1 | awk '{print $1}'
}

function kcontainer() {
    local POD="$1"
    local NAMESPACE="$2"
    if [ -z "$POD" ]; then
        echo "Must specify pod!"
        return 1
    fi

    local CMD=(kubectl get pod "$POD" -o json)
    if [ -n "$NAMESPACE" ]; then
        CMD+=(--namespace "$2")
    fi

    local CONTAINERS="$(${CMD[@]} | jq -r '.spec.containers[].name')"
    local CONTAINER="$(echo "$CONTAINERS" | fzf --select-1)"

    if [ "$CONTAINER" == "" ]; then
        echo "Must specify container for pod $POD. Choices: ${$(echo $CONTAINERS | paste -sd ', ' -)}"
        return 1
    fi

    echo "$CONTAINER"
}

function kexec() {
    local POD
    local CONTAINER
    local NAMESPACE
    local PARAMS=()

    while [ $# -gt 0 ]; do
        local key="$1"
        local value="$2"
        case "$1" in
            -p|--pod)
                POD=$value
                shift 2
                ;;
            -c|--container)
                CONTAINER=$value
                shift 2
                ;;
            -n|--namespace)
                NAMESPACE=$value
                shift 2
                ;;
            --) # end argument parsing and pass the rest as arguments to the logs command
                shift
                PARAMS+=($@)
                break
                ;;
            -*|--*=) # unsupported flags
                echo "Error: Unsupported flag $key" >&2
                return 1
                ;;
            *) # preserve positional arguments
                PARAMS+=("$key")
                shift
                ;;
        esac
    done
    # set positional arguments in their proper place
    set -- "${PARAMS[@]}"

    if [ -z "$POD" ]; then
        POD="$(kpod "$NAMESPACE")"
        local RET=$?
        if [ $RET -ne 0 ]; then
            echo "$POD"
            return $CODE
        fi
    fi

    if [ -z "$POD" ]; then
        echo "Must specify pod!"
        return 1
    fi

    if [ -z "$CONTAINER" ]; then
        CONTAINER="$(kcontainer "$POD" "$NAMESPACE")"
        local RET=$?
        if [ $RET -ne 0 ]; then
            echo "$CONTAINER"
            return $CODE
        fi
    fi

    if [ -z "$CONTAINER" ]; then
        echo "Must specify container!"
        return 1
    fi

    local COLUMNS=$(tput cols)
    local LINES=$(tput lines)
    local TERM=xterm
    local EXEC_CMD=(kubectl exec -i -t "$POD" -c "$CONTAINER")
    if [ -n "$NAMESPACE" ]; then
        EXEC_CMD+=(--namespace "$NAMESPACE")
    fi

    # test if bash exists, if it does, we'll use bash, otherwise use sh
    "${EXEC_CMD[@]}" -- test -e /bin/bash 2> /dev/null
    if [ $? -eq 0 ] ; then
        local KUBE_SHELL=${KUBE_SHELL:-/bin/bash}
    else
        local KUBE_SHELL=${KUBE_SHELL:-/bin/sh}
    fi

    EXEC_CMD+=(-- "$KUBE_SHELL")
    # if arguments are passed, then invoke our shell with -c, otherwise just
    # start an interactive login shell
    if [ $# -gt 0 ]; then
        EXEC_CMD+=(-c "$*")
    else
        EXEC_CMD+=(-il)
    fi
    echo "${EXEC_CMD[@]}"
    "${EXEC_CMD[@]}"
}

function klogs() {
    local POD
    local CONTAINER
    local NAMESPACE
    local PARAMS=()

    while [ $# -gt 0 ]; do
        local key="$1"
        local value="$2"
        case "$1" in
            -p|--pod)
                POD=$value
                shift 2
                ;;
            -c|--container)
                CONTAINER=$value
                shift 2
                ;;
            -n|--namespace)
                NAMESPACE=$value
                shift 2
                ;;
            --) # end argument parsing and pass the rest as arguments to the logs command
                shift
                PARAMS+=($@)
                break
                ;;
            -*|--*=) # unsupported flags
                echo "Error: Unsupported flag $key" >&2
                return 1
                ;;
            *) # preserve positional arguments
                PARAMS+=("$key")
                shift
                ;;
        esac
    done
    # set positional arguments in their proper place
    set -- "${PARAMS[@]}"

    if [ -z "$POD" ]; then
        POD="$(kpod "$NAMESPACE")"
        local RET=$?
        if [ $RET -ne 0 ]; then
            echo "$POD"
            return $CODE
        fi
    fi

    if [ -z "$POD" ]; then
        echo "Must specify pod!"
        return 1
    fi

    if [ -z "$CONTAINER" ]; then
        CONTAINER="$(kcontainer "$POD" "$NAMESPACE")"
        local RET=$?
        if [ $RET -ne 0 ]; then
            echo "$CONTAINER"
            return $CODE
        fi
    fi

    if [ -z "$CONTAINER" ]; then
        echo "Must specify container!"
        return 1
    fi

    local LOGS_CMD=(kubectl logs "$POD" -c "$CONTAINER")
    if [ -n "$NAMESPACE" ]; then
        LOGS_CMD+=(--namespace "$NAMESPACE")
    fi
    LOGS_CMD+=("$@")
    echo "${LOGS_CMD[@]}"
    "${LOGS_CMD[@]}"
}

test -e "${HOME}/.iterm2_shell_integration.zsh" && source "${HOME}/.iterm2_shell_integration.zsh"
